<!DOCTYPE html>
<html lang="uk">
  <head>
    <meta charset="UTF-8" />
    <title>Falling Shapes</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.0.0/pixi.min.js"></script>
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        text-align: center;
      }

      .container {
        width: 80vw;
        height: 50vh;
        max-width: 800px;
        max-height: 400px;
        border: 4px solid black;
        margin: 20px auto;
        background: white;
        overflow: hidden;
        position: relative;
      }

      .controls {
        margin: 20px;
      }

      .controls button {
        padding: 15px 30px;
        font-size: 20px;
        margin: 5px;
        border: none;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <h3>Falling Shapes</h3>
    <div>
      <p>NUMBER OF CURRENT SHAPES: <span id="shapeCount">0</span></p>
      <p>SURFACE AREA OCCUOIED BY SHAPES: <span id="shapeArea">0</span> pxÂ²</p>
    </div>
    <div class="container" id="canvas"></div>
    <div class="controls">
      <p>NUMBER OF SHAPES PER SECOND: <span id="shapeRate">1</span></p>
      <button onclick="fallingShapes.changeShapeRate(-1)">-</button>
      <button onclick="fallingShapes.changeShapeRate(1)">+</button>
      <p>GRAVITY VALUE: <span id="gravityValue">0.2</span></p>
      <button onclick="fallingShapes.changeGravity(-1)">-</button>
      <button onclick="fallingShapes.changeGravity(1)">+</button>
    </div>

    <script>
      class Shape {
        constructor(x, y, type, color, size, gravity, app, mask) {
          this.x = x;
          this.y = y;
          this.type = type;
          this.color = color;
          this.size = size;
          this.vy = gravity;
          this.app = app;
          this.shape = null;
          this.area = 0;
          this.mask = mask;

          this.createShape();
        }

        createShape() {
          const graphics = new PIXI.Graphics();
          graphics.beginFill(this.color);

          switch (this.type) {
            case "circle":
              graphics.drawCircle(0, 0, this.size / 2);
              this.area = Math.PI * (this.size / 2) ** 2;
              break;
            case "rectangle":
              graphics.drawRect(
                -this.size / 2,
                -this.size / 2,
                this.size,
                this.size
              );
              this.area = this.size * this.size;
              break;
            case "triangle":
              graphics.drawPolygon([
                -this.size / 2,
                this.size / 2,
                this.size / 2,
                this.size / 2,
                0,
                -this.size / 2
              ]);
              this.area = (this.size * this.size) / 2;
              break;
            case "pentagon":
              graphics.drawPolygon([
                0,
                -this.size / 2,
                this.size / 2,
                -this.size / 4,
                this.size / 3,
                this.size / 2,
                -this.size / 3,
                this.size / 2,
                -this.size / 2,
                -this.size / 4
              ]);
              this.area = (1.72 * this.size * this.size) / 4;
              break;
            case "star":
              const starPoints = [];
              const numPoints = 5;
              const outerRadius = this.size / 2;
              const innerRadius = this.size / 4;
              for (let i = 0; i < numPoints * 2; i++) {
                const angle = (i * Math.PI) / numPoints;
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const xOffset = Math.cos(angle) * radius;
                const yOffset = Math.sin(angle) * radius;
                starPoints.push(xOffset, yOffset);
              }
              graphics.drawPolygon(starPoints);
              this.area = (2.5 * this.size * this.size) / 4;
              break;
            case "irregular":
              this.createIrregularShape(graphics);
              break;
          }

          graphics.endFill();
          this.shape = graphics;
          this.shape.x = this.x;
          this.shape.y = this.y;

          this.shape.mask = this.mask;

          this.shape.interactive = true;
          this.shape.buttonMode = true;
          this.shape.on("pointerdown", () => this.removeShape());

          this.app.stage.addChild(this.shape);
        }

        createIrregularShape(graphics) {
          const numPoints = Math.floor(Math.random() * 6) + 3;
          const angleIncrement = (2 * Math.PI) / numPoints;
          const points = [];
          const vertices = [];

          for (let i = 0; i < numPoints; i++) {
            const angle = i * angleIncrement;
            const radius = (Math.random() * this.size) / 2 + this.size / 4;
            const xOffset = Math.cos(angle) * radius;
            const yOffset = Math.sin(angle) * radius;
            points.push(xOffset, yOffset);
            vertices.push({ x: xOffset, y: yOffset });
          }

          graphics.drawPolygon(points);

          this.area = this.calculateArea(vertices);
        }

        calculateArea(vertices) {
          let area = 0;
          const numVertices = vertices.length;

          for (let i = 0; i < numVertices; i++) {
            const j = (i + 1) % numVertices;
            area += vertices[i].x * vertices[j].y;
            area -= vertices[j].x * vertices[i].y;
          }

          return Math.abs(area) / 2;
        }

        removeShape() {
          this.app.stage.removeChild(this.shape);
          fallingShapes.removeShape(this);
        }

        update() {
          this.shape.y += this.vy;
        }
      }

      class FallingShapes {
        constructor() {
          this.gravity = 0.2;
          this.shapeRate = 1;
          this.shapes = [];
          this.isDeleting = false;

          this.container = document.getElementById("canvas");
          this.resizeCanvas();

          window.addEventListener("resize", () => this.resizeCanvas());
          this.app.ticker.add(this.animate.bind(this));
          this.updateShapeInterval();
        }

        resizeCanvas() {
          const { width, height } = this.container.getBoundingClientRect();

          if (this.app) {
            this.app.renderer.resize(width, height);
          } else {
            this.app = new PIXI.Application({
              width: width,
              height: height,
              backgroundColor: 0xffffff,
            });
            this.container.appendChild(this.app.view);
          }

          // Update mask
          if (this.mask) this.mask.destroy();
          this.mask = new PIXI.Graphics();
          this.mask.beginFill(0xffffff);
          this.mask.drawRect(0, 0, width, height);
          this.mask.endFill();
          this.app.stage.addChild(this.mask);
        }
        createShape(x, y) {
          const types = [
            "triangle",
            "rectangle",
            "circle",
            "pentagon",
            "star",
            "irregular"
          ];
          const type = types[Math.floor(Math.random() * types.length)];
          const color = Math.random() * 0xffffff;
          const size = Math.random() * 50 + 20;

          x = Math.max(
            size / 2,
            Math.min(this.app.renderer.width - size / 2, x)
          );

          const shape = new Shape(
            x,
            y,
            type,
            color,
            size,
            this.gravity,
            this.app,
            this.mask
          );
          this.shapes.push(shape);
          this.updateStats();
        }

        removeShape(shape) {
          this.isDeleting = true;
          this.shapes = this.shapes.filter((s) => s !== shape);
          this.updateStats();

          setTimeout(() => {
            this.isDeleting = false;
          }, 300);
        }

        updateStats() {
          const visibleShapes = this.shapes.filter(
            (shape) => shape.shape.y <= this.app.renderer.height
          );
          document.getElementById("shapeCount").textContent =
            visibleShapes.length;
          document.getElementById("shapeArea").textContent = visibleShapes
            .reduce((sum, shape) => sum + shape.area, 0)
            .toFixed(2);
        }

        animate() {
          this.shapes.forEach((shape, index) => {
            shape.update();

            if (shape.y - shape.size > this.app.renderer.height) {
              this.shapes.splice(index, 1);
              shape.destroy();
            }
          });

          this.updateStats();
        }

        changeShapeRate(value) {
          this.shapeRate = Math.max(1, this.shapeRate + value);
          document.getElementById("shapeRate").textContent = this.shapeRate;
          this.updateShapeInterval();
        }

        changeGravity(value) {
          this.gravity = Math.max(0.05, this.gravity + value * 0.05);
          document.getElementById("gravityValue").textContent =
            this.gravity.toFixed(2);
          this.shapes.forEach((shape) => (shape.vy = this.gravity));
        }

        updateShapeInterval() {
          clearInterval(this.shapeInterval);
          this.shapeInterval = setInterval(() => {
            for (let i = 0; i < this.shapeRate; i++) {
              this.createShape(Math.random() * this.app.renderer.width, -30);
            }
          }, 1000);
        }

        onCanvasClick(event) {
          if (this.isDeleting) return;

          const rect = this.app.view.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          this.createShape(x, y);
        }

        onCanvasTouch(event) {
          if (this.isDeleting) return;

          const rect = this.app.view.getBoundingClientRect();
          const touch = event.touches[0];
          const x = touch.clientX - rect.left;
          const y = touch.clientY - rect.top;
          this.createShape(x, y);
        }
      }

      const fallingShapes = new FallingShapes();

      document
        .getElementById("canvas")
        .addEventListener("click", (event) =>
          fallingShapes.onCanvasClick(event)
        );

      document
        .getElementById("canvas")
        .addEventListener("touchstart", (event) => {
          if (event.touches.length === 1) {
            fallingShapes.onCanvasTouch(event);
          }
        });
    </script>
  </body>
</html>
